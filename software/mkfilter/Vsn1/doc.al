<use ~/a4-11on14.fmt
<ft NCSR.11 NCSI.11 C.11
<tabs 4n 8n 12n

<tr `` x*   <tr '' x:	<tr fi x.   <tr fl x/
<tr -- x1	   \; en dash
<tr --- xP	   \; em dash
<tr _ h1n	   \; en space
<tr $ x2	   \; dagger
<tr % x'	   \; section
<tr ... x<	   \; Three Dots

<tr /= fS.11x9	   \; not equal
<tr \<= fS.11x#	   \; less than or equal
<tr \>= fS.11x3	   \; greater than or equal
<tr \< fS.11c<	   \; less than
<tr \> fS.11c>	   \; greater than

<tr |4 fS.14x|	   \; R brace top
<tr |5 fS.14x}	   \; R brace middle
<tr |6 fS.14x~	   \; R brace bottom
<tr || fS.14xo	   \; brace bar

<foot 1 1 < \g -- # -- \g >

<def PARA < \1 \need 2 ... \1 >
<def SUBS < <ft NCSI.11 - - \2 \need 4 \arg >ft \1 ... >
<def SECT < <ft NCSB.11 CBO.11 CB.11 \2 \need 4 \arg >ft \1 ... >
<def CHAP < \page <ft NCSB.11 - - <ce \arg >ce >ft \2 ... >
<def TABL < \1 ... \1 >

<text

<CHAP < Mkfilter >

<SECT < Introduction >

{ #m#k#f#i#l#t#e#r is a program which
designs an infinite impulse response digital filter from parameters
specified on the command line, using the bilinear transform method. }


{ The source code of the program (in C) is at

<TABL <ft C.11 - -
\t http://dcpu1.cs.york.ac.uk:6666/fisher/software/mkfilter
>ft >TABL

and there is a World Wide Web form-based front end at

<TABL <ft C.11 - -
\t http://dcpu1.cs.york.ac.uk:6666/fisher/mkfilter
>ft >TABL }

{ In normal use, the output of the program is a set of S- and Z-plane
pole and zero positions, the filter recurrence relation, and some other
information in human-readable form.  By specifying the #-#l
parameter, computer-readable output is produced which can be piped into
other programs.	 In particular, the program #g#e#n#c#o#d#e takes the #-#l
output from #m#k#f#i#l#t#e#r and generates a piece of C code which implements
the filter, and the program #g#e#n#p#l#o#t takes the #-#l output and
generates a #g#i#f file containing phase and magnitude graphs._ #g#e#n#c#o#d#e
has no parameters._ #g#e#n#p#l#o#t has one, the name of the output #g#i#f file. }

{ #g#e#n#p#l#o#t uses the #g#d gif manipulation library from
Quest Protein Database Center, #<#h#t#t#p#:#/#/#s#i#v#a#.#c#s#h#l#.#o#r#g#/#g#d#/#g#d#.#h#t#m#l#>. }

{ A warning about higher-order Bessel filters:	although an analogue
Bessel filter has an excellent approximation to a linear phase
characteristic, the pre-warping inherent in the bilinear transform
design method upsets this, and the corresponding digital filter often
deviates significantly from linear phase.  This is particularly evident
in the higher-order Bessel filters (say ^N_>_2).	 You're advised to study
the graphs produced by #g#e#n#p#l#o#t before you use any Bessel filter
generated by this package. }

>SECT

<SECT < Mkfilter Command Line Parameters >

{ ``[]'' means ``optional''. }

<SUBS < >

{ The following parameters are required: }

<TABL
< #-#B#e	\t |4 \tf Filter type:	Bessel, Butterworth or Chebyshev,
		  respectively.	 Exactly one >
< #-#B#u	\t |5 \tf of these options must be specified.  The parameter ^r
		  is the passband >
< #-#C#h ^r \t |6 \tf ripple in dB,
		  meaningful for Chebyshev designs only.  NB:_ ^r \< 0. >
>TABL

<TABL
< #-#L#p	\t |4 \tf Pass type:  Low-pass, High-pass or Band-pass,
		  respectively. >
< #-#H#p	\t |5 \tf Exactly one of these options must be specified. >
< #-#B#p	\t |6 \tf >
>TABL

\need 2

<TABL
#-#a ^a\1 [^a\2] \tf Corner (--3dB) frequency/ies, as a fraction of the
sampling rate; i.e. 0.5 is the Nyquist frequency.  For low-pass and
high-pass filters, only ^a\1 is required.	 For band-pass, both ^a\1
(the lower corner frequency) and ^a\2 (the upper corner frequency) are
required.  NB:_ 0_<_^a\1_<_0.5;_ 0_<_^a\2_<_0.5; a\1_<_a\2.
>TABL

<TABL
#-#o ^N \t \tf Order of filter.  NB:_ 1_<=_^N_<=_10.
The attenuation in the stopband is 6^N_dB
per octave.  The number of S- and Z-plane poles and
zeros is related to ^N as follows.
>TABL

<TABL <tabs 1.0i 2.0i 2.8i 3.6i 4.4i
< \t		   \t S-poles \t S-zeros \t Z-poles \t Z-zeros	>
< \t Low-pass:	   \t __^N     \t __---	   \t  __^N  \t ^N at --1 >
< \t High-pass	   \t __^N     \t ^N at 0	 \t  __^N    \t ^N at +1	>
< \t Band-pass:	   \t _2^N     \t ^N at 0	 \t  _2^N    \t ^N at --1, ^N at +1 >
>tabs >TABL

<TABL
\t \t \tf Note in particular that in a bandpass filter the number of
poles is twice the order.
>TABL

>SUBS

<SUBS < >

{ The following parameters are optional: }

<TABL
#-#e \t \t \tf Execute filter.  Instead of printing a filter design, the
program accepts a stream of real numbers on stdin, executes the filter,
and prints the filtered output stream on stdout.  Input and output values
are presented one to a line.
>TABL

<TABL
#-#l \t \t \tf List output in a form suitable for piping to another
program.  Instead of printing a filter design, the program prints the
following:  the command line; the number ^P of Z-plane poles; and 2(^P+1)
further numbers which are the coefficients of ^x`i and ^y`i in the
recurrence relation.  A trial run, specifying the same parameters both
with and without #-#l, will make this clear.
>TABL

<TABL
#-#p ^p\1 ^p\2 ... \tf Select only poles ^p\1, ^p\2, ..., where 0_<=_^p`i_<=_^N.
Sometimes it is convenient (e.g. to reduce roundoff error) to partition
a filter into sections.	 This option allows you to choose a subset of
S-plane poles from the complete set.  The subset selected must itself be
partitioned into complex conjugate pairs.  Some trial and error is
required to achieve this!  You will be told if you have not got it
right.
>TABL

<TABL
#-#w \t \t \tf Don't pre-warp the corner frequencies.  This is useful
when you're interested in the S-plane pole positions for an ^a^n^a^l^o^g^u^e
filter.	 If you specify #-#w the generated digital filter will be ^w^r^o^n^g^.
>TABL

>SUBS

>SECT

\need 9

<SECT < Examples >

<TABL
< \t #m#k#f#i#l#t#e#r #-#B#u #-#L#p #-#o #4 #-#a #0#.#2 >
< \t \t Generate a 4-pole Butterworth low-pass filter with corner
	frequency 0.2 ^f`S; >
< \t \t display pole & zero positions and filter recurrence relation >
>TABL

<TABL
< \t #m#k#f#i#l#t#e#r #-#B#u #-#L#p #-#o #4 #-#a #0#.#2 #-#l #| #g#e#n#c#o#d#e >
< \t \t Generate C code for the above filter >
>TABL

<TABL
< \t #m#k#f#i#l#t#e#r #-#B#u #-#L#p #-#o #4 #-#a #0#.#2 #-#l #| #g#e#n#p#l#o#t #g#r#a#p#h#.#g#i#f >
< \t \t Generate phase & magnitude graphs for the above filter >
>TABL

>SECT

<SECT < Contact >

<in 0.5i

< Dr Anthony J. Fisher >
< Dept of Computer Science >
< The University of York >
< York YO1 5DD, U.K. >
\1
< #f#i#s#h#e#r#@#m#i#n#s#t#e#r#.#y#o#r#k#.#a#c#.#u#k >
< #h#t#t#p#:#/#/#d#c#p#u#1#.#c#s#.#y#o#r#k#.#a#c#.#u#k#:#6#6#6#6#/#f#i#s#h#e#r >

>in

\3
< \g 19th August 1995 >

>SECT

>CHAP

